int sc_read_binary(sc_card_t *card, unsigned int idx,
		   unsigned char *buf, size_t count, unsigned long *flags)
{
	size_t max_le = sc_get_max_recv_size(card);
	size_t todo = count;
	int r;

	if (card == NULL || card->ops == NULL || buf == NULL) {
		return SC_ERROR_INVALID_ARGUMENTS;
	}
	sc_log(card->ctx, "called; %"SC_FORMAT_LEN_SIZE_T"u bytes at index %d",
	       count, idx);
	if (count == 0)
		LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);

#ifdef ENABLE_SM
	if (card->sm_ctx.ops.read_binary)   {
		r = card->sm_ctx.ops.read_binary(card, idx, buf, count);
		if (r)
			LOG_FUNC_RETURN(card->ctx, r);
	}
#endif

	if (card->ops->read_binary == NULL)
		LOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);

	/* lock the card now to avoid deselection of the file */
	r = sc_lock(card);
	LOG_TEST_RET(card->ctx, r, "sc_lock() failed");

	while (todo > 0) {
		size_t chunk = MIN(todo, max_le);

		r = card->ops->read_binary(card, idx, buf, chunk, flags);
		if (r == 0 || r == SC_ERROR_FILE_END_REACHED)
			break;
		if (r < 0 && todo != count) {
			/* the last command failed, but previous ones succeeded.
			 * Let's just return what we've successfully read. */
			sc_log(card->ctx, "Subsequent read failed with %d, returning what was read successfully.", r);
			break;
		}
		if (r < 0) {
			sc_unlock(card);
			LOG_FUNC_RETURN(card->ctx, r);
		}
		if ((idx > SIZE_MAX - (size_t) r) || (size_t) r > todo) {
			/* `idx + r` or `todo - r` would overflow */
			sc_unlock(card);
			LOG_FUNC_RETURN(card->ctx, SC_ERROR_OFFSET_TOO_LARGE);
		}

		todo -= (size_t) r;
		buf  += (size_t) r;
		idx  += (size_t) r;
	}

	sc_unlock(card);

	LOG_FUNC_RETURN(card->ctx, count - todo);
}
static int read_public_key(RSA *rsa)
{
	int r;
	sc_path_t path;
	sc_file_t *file;
	u8 buf[2048], *p = buf;
	size_t bufsize, keysize;

	r = select_app_df();
	if (r)
		return 1;
	sc_format_path("I1012", &path);
	r = sc_select_file(card, &path, &file);
	if (r) {
		fprintf(stderr, "Unable to select public key file: %s\n", sc_strerror(r));
		return 2;
	}
	bufsize = file->size;
	sc_file_free(file);
	r = sc_read_binary(card, 0, buf, bufsize, 0);
	if (r < 0) {
		fprintf(stderr, "Unable to read public key file: %s\n", sc_strerror(r));
		return 2;
	}
	bufsize = r;
	do {
		if (bufsize < 4)
			return 3;
		keysize = (p[0] << 8) | p[1];
		if (keysize == 0)
			break;
		if (keysize < 3)
			return 3;
		if (p[2] == opt_key_num)
			break;
		p += keysize;
		bufsize -= keysize;
	} while (1);
	if (keysize == 0) {
		printf("Key number %d not found.\n", opt_key_num);
		return 2;
	}
	return parse_public_key(p, keysize, rsa);
}