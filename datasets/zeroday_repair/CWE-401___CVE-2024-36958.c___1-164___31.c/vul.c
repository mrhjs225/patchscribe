static __be32
nfsd4_encode_fattr4(struct svc_rqst *rqstp, struct xdr_stream *xdr,
		    struct svc_fh *fhp, struct svc_export *exp,
		    struct dentry *dentry, const u32 *bmval,
		    int ignore_crossmnt)
{
	DECLARE_BITMAP(attr_bitmap, ARRAY_SIZE(nfsd4_enc_fattr4_encode_ops));
	struct nfsd4_fattr_args args;
	struct svc_fh *tempfh = NULL;
	int starting_len = xdr->buf->len;
	__be32 *attrlen_p, status;
	int attrlen_offset;
	u32 attrmask[3];
	int err;
	struct nfsd4_compoundres *resp = rqstp->rq_resp;
	u32 minorversion = resp->cstate.minorversion;
	struct path path = {
		.mnt	= exp->ex_path.mnt,
		.dentry	= dentry,
	};
	unsigned long bit;
	bool file_modified = false;
	u64 size = 0;

	WARN_ON_ONCE(bmval[1] & NFSD_WRITEONLY_ATTRS_WORD1);
	WARN_ON_ONCE(!nfsd_attrs_supported(minorversion, bmval));

	args.rqstp = rqstp;
	args.exp = exp;
	args.dentry = dentry;
	args.ignore_crossmnt = (ignore_crossmnt != 0);

	/*
	 * Make a local copy of the attribute bitmap that can be modified.
	 */
	attrmask[0] = bmval[0];
	attrmask[1] = bmval[1];
	attrmask[2] = bmval[2];

	args.rdattr_err = 0;
	if (exp->ex_fslocs.migrated) {
		status = fattr_handle_absent_fs(&attrmask[0], &attrmask[1],
						&attrmask[2], &args.rdattr_err);
		if (status)
			goto out;
	}
	args.size = 0;
	if (attrmask[0] & (FATTR4_WORD0_CHANGE | FATTR4_WORD0_SIZE)) {
		status = nfsd4_deleg_getattr_conflict(rqstp, d_inode(dentry),
					&file_modified, &size);
		if (status)
			goto out;
	}

	err = vfs_getattr(&path, &args.stat,
			  STATX_BASIC_STATS | STATX_BTIME | STATX_CHANGE_COOKIE,
			  AT_STATX_SYNC_AS_STAT);
	if (err)
		goto out_nfserr;
	if (file_modified)
		args.size = size;
	else
		args.size = args.stat.size;

	if (!(args.stat.result_mask & STATX_BTIME))
		/* underlying FS does not offer btime so we can't share it */
		attrmask[1] &= ~FATTR4_WORD1_TIME_CREATE;
	if ((attrmask[0] & (FATTR4_WORD0_FILES_AVAIL | FATTR4_WORD0_FILES_FREE |
			FATTR4_WORD0_FILES_TOTAL | FATTR4_WORD0_MAXNAME)) ||
	    (attrmask[1] & (FATTR4_WORD1_SPACE_AVAIL | FATTR4_WORD1_SPACE_FREE |
		       FATTR4_WORD1_SPACE_TOTAL))) {
		err = vfs_statfs(&path, &args.statfs);
		if (err)
			goto out_nfserr;
	}
	if ((attrmask[0] & (FATTR4_WORD0_FILEHANDLE | FATTR4_WORD0_FSID)) &&
	    !fhp) {
		tempfh = kmalloc(sizeof(struct svc_fh), GFP_KERNEL);
		status = nfserr_jukebox;
		if (!tempfh)
			goto out;
		fh_init(tempfh, NFS4_FHSIZE);
		status = fh_compose(tempfh, exp, dentry, NULL);
		if (status)
			goto out;
		args.fhp = tempfh;
	} else
		args.fhp = fhp;

	args.acl = NULL;
	if (attrmask[0] & FATTR4_WORD0_ACL) {
		err = nfsd4_get_nfs4_acl(rqstp, dentry, &args.acl);
		if (err == -EOPNOTSUPP)
			attrmask[0] &= ~FATTR4_WORD0_ACL;
		else if (err == -EINVAL) {
			status = nfserr_attrnotsupp;
			goto out;
		} else if (err != 0)
			goto out_nfserr;
	}

	args.contextsupport = false;

#ifdef CONFIG_NFSD_V4_SECURITY_LABEL
	args.context = NULL;
	if ((attrmask[2] & FATTR4_WORD2_SECURITY_LABEL) ||
	     attrmask[0] & FATTR4_WORD0_SUPPORTED_ATTRS) {
		if (exp->ex_flags & NFSEXP_SECURITY_LABEL)
			err = security_inode_getsecctx(d_inode(dentry),
						&args.context, &args.contextlen);
		else
			err = -EOPNOTSUPP;
		args.contextsupport = (err == 0);
		if (attrmask[2] & FATTR4_WORD2_SECURITY_LABEL) {
			if (err == -EOPNOTSUPP)
				attrmask[2] &= ~FATTR4_WORD2_SECURITY_LABEL;
			else if (err)
				goto out_nfserr;
		}
	}
#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */

	/* attrmask */
	status = nfsd4_encode_bitmap4(xdr, attrmask[0], attrmask[1],
				      attrmask[2]);
	if (status)
		goto out;

	/* attr_vals */
	attrlen_offset = xdr->buf->len;
	attrlen_p = xdr_reserve_space(xdr, XDR_UNIT);
	if (!attrlen_p)
		goto out_resource;
	bitmap_from_arr32(attr_bitmap, attrmask,
			  ARRAY_SIZE(nfsd4_enc_fattr4_encode_ops));
	for_each_set_bit(bit, attr_bitmap,
			 ARRAY_SIZE(nfsd4_enc_fattr4_encode_ops)) {
		status = nfsd4_enc_fattr4_encode_ops[bit](xdr, &args);
		if (status != nfs_ok)
			goto out;
	}
	*attrlen_p = cpu_to_be32(xdr->buf->len - attrlen_offset - XDR_UNIT);
	status = nfs_ok;

out:
#ifdef CONFIG_NFSD_V4_SECURITY_LABEL
	if (args.context)
		security_release_secctx(args.context, args.contextlen);
#endif /* CONFIG_NFSD_V4_SECURITY_LABEL */
	kfree(args.acl);
	if (tempfh) {
		fh_put(tempfh);
		kfree(tempfh);
	}
	if (status)
		xdr_truncate_encode(xdr, starting_len);
	return status;
out_nfserr:
	status = nfserrno(err);
	goto out;
out_resource:
	status = nfserr_resource;
	goto out;
}
